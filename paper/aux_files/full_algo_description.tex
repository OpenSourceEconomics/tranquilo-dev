\section{The trustregion algorithm}
\label{sec:algo}
the main loop of tranquilo
\begin{itemize}
    \item initialize
   \item for k in range(maxiter):
   \item define search region (around the candidate) based on trustregion radius and search radius factor
   \item get all the points from the history that lie within the search region
   \item obtain the existing sample points by filtering the points from the previous step
        \begin{itemize}
            \item keep all - default
            \item discard all - keep only candidate point
            \item keep cluster centers
            \item drop excess - drop worst points to retain sample of target size: start dropping points outside trust region, then drop those that are closest to the center
        \end{itemize}
   \item get information on number of evaluations per model points
   \item get number of new to points to sample based on target sample size and number of existing points
   \item evaluate function at new points
   \item add new indices to the model indices
   \item fit the residuals to the model data
        \begin{itemize}
            \item using ols
            \item using ridge regression: penalizing with l2 norm
            \item using powell fitting method which switches between penalized and unpenalized fitting depending on the sample size
            \item using tranquilo which penalizes the linear terms less strongly when the system is underdetermined
            \item the default fitter for linear model type or identified system is ols, otherwise-tranquilo.
        \end{itemize}
   \item find the optimum of the fitted model
        \begin{itemize}
            \item bntr - default cube subsolver
            \item gqtpar - default sphere subsolver
            \item slsqp - sphere subsolver, wrapped from scipy
            \item multistar - multistart subsolver using lbfgsb
        \end{itemize}
   \item drop sample points if we have enough  and the step length is too small, refit and repeat until the step length is large enough
   \item if step length is still too small, drop and resample
   \item if the problem is noisy, estimate noise covariance: variance of function evaluations

   \item do the acceptance decision () based on expected and actual improvements
        \begin{itemize}
            \item if batch size is 1 (no parallelization): do classic acceptance based on rhos
            \item else, check if the candidate point is at the tr border
            \item if yes, get number of line search points (at most 3, at least batch size-1) and define the grid on the line
            \item calculate number of unallocated function evals based on the number of points on the line search and batch size (batch_size-1-n_evals_line_search) WHY batch_size-1 ?????
            \item if the previous number is non-zero, do speculative sampling around the candidate point using search radius
            \item add the line search and speculative points, if any, to the history
            \item calculate new function value as the mean of all function evaluations at candidate x
            \item calculate actual improvement
            \item calculate rho
            \item check if criterion is smaller at any of the new points (spec+line search)
            \item if so, replace candidate f val with that value
            \item accept if actual improvement is larger than min improvement: accept as a candidate point. then based on the rho set as new tr center. WHY: we accept based using the new points, but the rho is calculated before that??????
            \item if noisy evaluate function at currend index and candidate index n1 and n2 times, repsecitvely through power analysis using the noise variance and expected improvement as minial effect size
        \end{itemize}
   \item update the state information of the current iteration and append to states list
   \item if noisy, calculate the rho noise and update number of evaluations
   \item update radius and trust region based on acceptance decision, rho and whether number of evaluations needs to increase or not
   \item if candidate accepted and convergence achieved, break
   \item if max fun evaluations reached, break
\end{itemize}
