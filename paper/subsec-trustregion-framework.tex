
\subsection{The trust region framework}
\label{subsec:tr-framework}
%%TODO
% 1. define notation for the building blocks write equations for the interface and data flow
% 2. write down algorithm listing
In each iteration $t$, given current candidate point $x^*_t$ and search radius $\Delta^{search}_t=\gamma^{search}\Delta_t^{region}$, we begin by screening the history of criterion evaluations to retrieve all points that lie within the neighborhood $\Delta^{search}_t$ of $x_t$:
\begin{align}
    \mathcal{S}^{existing}_t\equiv\{x\in\mathcal{H}|\Hquad\lVert x^*_t-x\rVert\leq\Delta^{search}_t\}
    \label{eq:hist-search}
\end{align}
We then apply a filter function to the set of existing points points:
\begin{align}
    \mathcal{S}^{filtered}_t\equiv Filter (\mathcal{S}^{existing}_t) = \{ Filter (x)|\Hquad x\in \mathcal{S}^{existing}_t\}
    \label{eq:filtering}
\end{align}
Specific implementations of function $Filter$ can, for example be applied to  improve the quality of the sample geometry, reduce clustering, or effectively switch of filtering by keeping all existing points. \comment[id=MP]{TODO Mariam: add examples from /refer to wild paper}

If the size of the filtered sample is smaller than the target sample size, we sample new points in the current trust region:

\begin{align}
    \mathcal{S}^{new}_{t}\equiv Sample(\mathcal{S}_t^{filtered},B_t,n^{target})
    \label{eq:sample-points}
\end{align}

We approximate the residual vector $r$ by fitting a vector model to sample points $x_t\in\mathcal{S}_t^{model}\equiv\mathcal{S}^{filtered}_t\cup\mathcal{S}^{new}_t$ and the corresponding residual evaluations $y_t=r(x_t)$:
\begin{align}
    r\approx M_t^v\equiv Fit(x_t;r,B_t)
\end{align}
where the fitter function is constructed such that it's applicable for both regression ($|\mathcal{S}^{model}_t|\geq p$) and interpolation ($|\mathcal{S}^{model}_t|\leq p$) problems. Additional dependency on the trust region $B_t$ is necessary to scale the model to a unit circle to facilitate solving for the minimum of the scalar model. We obtain the scalar model by aggregating the vector model:
\begin{align}
    M_t^s = Aggregate(M_t^v)
    \label{eq:aggregate-model}
\end{align}
where the $Aggregate$ function allows for a number of aggregation strategies, discussed in section \ref{subsubsec:aggregation}


To find a candidate step $s_t$, we approximately solve for the optimum of the aggregate model:\comment[id=MP]{equation 2.10 in DFOLS paper imposes condition on the step size to }
\begin{align}
    s_t\approx arg\,\min\limits_sM_t^s(x_t+s)
    \label{eq:cand-step}
\end{align}

Following \cite{PowellBobyqa}, we impose a lower threshold on the step size $\lVert s_t\rVert$ to accept a candidate step. To this end, we iteratively improve sample quality, fit the model and solve \ref{eq:cand-step} until we obtain a large enough candidate step.

We evaluate the aggregate criterion $f$ at the new candidate point $x^{*}_t+s_t$, and compute the decrease in the objective produced by the candidate step:
\begin{align}
    \Delta f_t\equiv f(x_t^*) - f(x_t^*+s_t)
    \label{eq:actual-improvement}
\end{align}

Similarly, we compute the expected improvement predicted my the aggregate model:
\begin{align}
    \Delta M^{s}_t\equiv M_t^s(x_t^*) - M_t^s(x_t^*+s_t)
    \label{eq:expected-improvement}
\end{align}

In a comprehensive acceptance step, details of which we will discuss in sections \ref{subsubsec:acceptance} (\textcolor{red}{add references to acceptance details in noisy and parallel cases}), we take into the actual and expected improvements $\Delta f_t$ and $\Delta M_t^s$, to obtain the candidate point for the next iteration $x_{t+1}^*$ and the relative improvement $\rho_t\equiv \Delta f_t/ \Delta M^s_t$:

\begin{align}
    Accept(s_t,x_t^{*},\Delta f_t,\Delta M_t^s;\Hquad\cdot\Hquad)=(Decision_t,x_{t+1}^{*},\rho_t;\Hquad\cdot\Hquad)
    \label{eq:acceptance-core}
\end{align}
The classical trust region acceptance decision:
\begin{align}
    x_{t+1}^*=\begin{cases}
        x_t^*+s_t,\quad&\rho_t\geq\rho^{min}\\
        x_t^*,\quad&\rho_t<\rho^{min}
    \end{cases}
    \label{eq:accept-classic}
\end{align}
is encompassed in our acceptance step as a special case.

Having obtained the acceptance results, we expand the trust region radius by a factor $\gamma^{inc}>1$ if both the ratio $\rho_t$ and the step size $\lVert s_t\rVert$ are sufficiently large:
 \begin{align}
    \Delta_{t+1}^{region} = \gamma^{inc}\Delta_t^{region}
 \end{align}

We shrink the trust region radius for low values of $\rho_t$:
\begin{align}
    \Delta_{t+1}^{region} = \gamma^{dec}\Delta_t^{region}
 \end{align}

We summarize the Tranquilo core algorithm in Algorithm \ref{algo:core}.
\newpage

\begin{algorithm}[H]
    \caption{Tranquilo main loop}\label{algo:core}
    \KwIn{
    Starting point $x^*_0\in\mathbb{R}^p$, initial trust region radius $\Delta^{tr}_0$, and target sample size $n^{target}$.

    Initial sample $\mathcal{S}_0\subset R(x_0,\Delta_0^{tr})$ with $|\mathcal{S}_0|=n^{target}$

    Other parameters: Search factor $\gamma^{search}$, minimum step size $s^{min}$, minimum relative improvement $\rho^{min}$, trust region expansion and shrinking factors $0<\gamma^{dec}<1<\gamma^{inc}$, and maximum number of iterations $t^{max}$


    }
    \For{t=0,1,2,...}{
        Given $x_t^*$ and $\Delta_t^{search}=\gamma^{search}\Delta^{tr}_{t}$, scan history for points in the search region: $\mathcal{E}_t = \{x\in\mathcal{H}|\Hquad\lVert x^*_t-x\rVert\leq\Delta^{search}_t\}$\\
        Filter existing points: $\mathcal{E}'_t\equiv Filter (\mathcal{E}_t) = \{ Filter (x)|\Hquad x\in \mathcal{E}_t\}$\\
        \If{$|E_t^{'}|<n^{target}$}{
            Sample new points in the trust region: $\mathcal{N}_t\equiv\mathbb{B}(\mathcal{E}_t^{'},R_t,n^{target})$
        }
        Given $x_t^*$ and $\mathcal{S}_t\equiv\mathcal{E}^{'}_t\cup\mathcal{N}_t$, build the vector model $M_t^v\equiv Fitter(x_t,y_t;R_t,M_{t-1}^v)$\label{algo-core-line:fit}\\
        Solve for the optimum of the scalar model $M_t^s$: $s_t\approx arg\,\min\limits_sM_t^s(x_t+s)$\label{algo-core-line:solve}\\
        \If{$|\mathcal{S}_t|>n^{target}$}{
            \While{$s_t\leq s^{min}$}{
                Drop sample points\\
                Build the vector model (step \ref{algo-core-line:fit})\\
            Solve for the optimum of scalar model (step \ref{algo-core-line:solve})
            }
        }

        \While{$\lVert s_t\rVert\leq s^{min}$}{
            Drop points and resample\\
            Build the vector model (step \ref{algo-core-line:fit})\\
            Solve for the optimum of scalar model (step \ref{algo-core-line:solve})
        }
        \nonl Acceptance decision:\\
         Calculate $\rho_t=\frac{F(x^{*}_t)-F(x_t^{*}+s_t)}{M^s_t(x^{*}_t)-M^s_t(x_t^{*}+s_t)}$\\
         \eIf{$\rho\geq\rho^{min}$}{
         Set $x_{t+1}^{*} = x_t^{*} + s_t$ and increase trust region radius $\Delta^{tr}_{t+1}=\gamma^{inc}\Delta^{tr}_t$

        }{
            Set $x_{t+1}^{*}=x_{t}^*$ and shrink trust region radius $\Delta^{tr}_{t+1}=\gamma^{dec}\Delta^{tr}_t$

        }
    \If{$t>t^{max}$ or $converged$}{\textbf{break}}
    }

    \end{algorithm}
