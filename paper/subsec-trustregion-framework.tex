
\subsection{The trust region framework}
\label{subsec:tr-framework}
In this section we review the general trust region framework and the main components of the Tranquilo algorithm. The specific functional forms of the components are further discussed in section \ref{subsec:core-implementation}. We provide the full statement of Tranquilo in Algorithm \ref{algo:core}.
\newpage
\newgeometry{left=15mm,right=15mm, bottom=3cm}
\begin{algorithm}[H]
    \caption{Tranquilo algorithm}\label{algo:core}
    \KwIn{
    Starting point $x^*_0\in\mathbb{R}^p$, initial trust region radius $\Delta^{region}_0$, and target sample size $n^{target}$.

    Other constants: Search factor $\gamma^{search}$, minimum step size $s^{min}$, relative improvement cut-offs $0<\rho^{1}<\rho^2$, trust region radius adjustment factors $0<\gamma^{dec}<1<\gamma^{inc}$, sample increment $n^{drop}$, and maximum number of iterations $t^{max}$

    A convergence criterion.

    Initialize history with $\mathcal{H}_0=\{(x^*_0,r(x_0^*))\}$.

    }
    \For{t=0,1,2,...}{
        Given $x_t^*$ and $\Delta_t^{search}=\gamma^{search}\Delta^{region}_{t}$, scan history for points in the search region: $\mathcal{X}^{existing}_t = \{x\in\mathcal{H}_t|\Hquad\lVert x^*_t-x\rVert\leq\Delta^{search}_t\}$\\
        Filter existing points: $\mathcal{X}^{filtered}_t\equiv Filter(\mathcal{X}^{existing}_t) \equiv\{Filter(x)|\Hquad x\in \mathcal{X}^{existing}_t\}$\\
        \If{$|\mathcal{X}_t^{filtered}|<n^{target}$}{
            Sample new points in the trust region: $\mathcal{X}^{new}_t\equiv Sample(\mathcal{X}_t^{filtered},R_t,n^{target})$
        }
        Build a vector model $M_t^v\equiv Fit(\mathcal{X}_t^{model};r,R_t)$ on $\mathcal{X}^{model}_t\equiv\mathcal{X}^{filtered}_t\cup\mathcal{X}^{new}_t$\label{algo-core-line:fit}\\
        Aggregate the vector model: ${M}_t^s = Aggregate(M_t^v)$\label{algo-core-aggregate}\\
        Solve the surrogate problem: $s_t\approx\underset{s\in B_t}{arg\,\min\Hquad}M_t^s(s)$\label{algo-core-line:solve}\\

            \While{$|\mathcal{X}^{model}_t|>n^{target}$ and $\lVert s_t\rVert\leq s^{min}$}{
                Reduce the sample: $\mathcal{X}_t^{reduced}=Drop(\mathcal{X}_t^{model}, n^{drop},\Delta_t^{region})$ and set $\mathcal{X}_t^{model}=\mathcal{X}_t^{reduced}$\label{algo-core-listing-improve-geo}\\
                Build a vector model: $M_t^v\equiv Fit(\mathcal{X}_t^{model};r,R_t)$\\
                Aggregate the vector model: ${M}_t^s = Aggregate(M_t^v)$\\
                Solve the surrogate problem: $M_t^s$: $s_t\approx\underset{s\in B_t}{arg\,\min\Hquad}M_t^s(s)$\\
                }



        \While{$\lVert s_t\rVert\leq s^{min}$}{
            Reduce the sample: $\mathcal{X}_t^{reduced}=Drop(\mathcal{X}_t^{model}, n^{drop},\Delta_t^{region})$\label{algo-core-listing-improve-geo}\\
            Sample new points: $\mathcal{X}_t^{new} = Sample(\mathcal{X}_t^{reduced},R_t,n^{drop})$\\
            Build a vector model: $M_t^v\equiv Fit(\mathcal{X}_t^{model};r,R_t)$ on $\mathcal{X}_t^{model}=\mathcal{X}_t^{reduced}\cup\mathcal{X}_t^{new}$\\
            Aggregate the vector model: ${M}_t^s = Aggregate(M_t^v)$\\
            Solve the surrogate problem: $s_t\approx\underset{s\in B_t}{arg\,\min}M_t^s(s)$\\
        }
         Calculate $\Delta f_t\equiv f(x_t^*) - f(x_t^*+s_t)$ and $\Delta M^{s}_t\equiv M_t^s(x_t^*) - M_t^s(x_t^*+s_t)$\\
         \nonl \textbf{Acceptance decision}:\\
         $(Decision_t,x_{t+1}^*,\rho_t;\Hquad\cdot\Hquad) =  Accept(s_t,x_t^{*},\Delta f_t,\Delta M_t^s;\Hquad\cdot\Hquad)$\\
         \uIf{$\rho_t\geq\rho^{2}$ and  $s_t$ is large}{
         Expand trust region radius: $\Delta^{region}_{t+1}=\gamma^{inc}\Delta^{region}_t$

        }
        \uElseIf{$\rho_t>\rho^1$}{
        Leave the radius unchanged: $\Delta_{t+1}^{region}=\Delta_t^{region}$
        }
        \uElse{
        Shrink trust region radius $\Delta^{region}_{t+1}=\gamma^{dec}\Delta^{region}_t$
        }
    \If{$t>t^{max}$ or $converged$}{\textbf{break}}
    }

    \end{algorithm}
\newpage
\restoregeometry

At the beginning of an iteration $t$, we are equipped with the following information:
\begin{itemize}
    \item\textit{Candidate point} $x_t^*\in\mathbb{R}^p$.

\item \textit{Trust region} defined by its radius $\Delta_t^{region}$ and center $x_t^*\in\mathbb{R}^p$ as follows:
\begin{align}
    R_t\equiv R(x_t^*,\Delta_t^{region})\equiv\{x\in\mathbb{R}^p|\Hquad\lVert x-x_t\rVert\leq\Delta_t^{region}\}
    \label{eq:def-trustregion}
\end{align}
where $\lVert\cdot\rVert$ denotes the 2-norm of a vector.

\item \textit{History} of function evaluations $\mathcal{H}_t$.

\item \textit{Constants} 1) Target sample size $n^{target}$, 2) Search factor, $\gamma^{search}$, 3) Trust region radius adjustment factors $0<\gamma^{dec}<1<\gamma^{inc}$, 4) The function value improvement cutoffs for trust region radius adjustment, $0<\rho^1<\rho^2$, and 5) Minimum step length $s^{min}$
\end{itemize}


\paragraph{The main loop} As in classical model-based trust region algorithms, in each iteration we approximate the residual vector function by a surrogate model:

\begin{align}
    r(x_t^*+s)\approx M_t^v(s)
    \label{eq:vec-model}
\end{align}
where $M_t^v = \{M_t^1,\dots,M_t^k\}$, and the residual models $M^i_t$ can be polynomials of up to second degree. Note that we center the vector model around the current candidate point $x_t^*$.


To build a model $M_t^v$, we solve a fitting problem on a set of model points $\mathcal{X}^{model}=\{x_t^*,x_1,\dots,x_{n_{t}-1}\}\subset\mathbb{R}^p$ and corresponding evaluations $\{r(x_t)|\Hquad x_t\in\mathcal{X}^{model}\}$. The Tranquilo fitting function can be applied to both underdetermined (when $n_t$ is smaller than the degrees of freedom of the residual models), just determined ($n_t=DoF(M^i)$) and over determined ($n_t>DoF(M^i_t))$ regression problems. We therefore offer the following general formulation of the fitting problem:
\begin{align}
    M_t^v\equiv Fit(\mathcal{X}_t^{model};r,R_t)
    \label{eq:fit-model}
\end{align}
where the additional dependency on the trust region $R_t$ is necessary to scale the parameter vectors to either a unit hypershpere (unconstrained optimization) or a $[-1,1]^p$ hypercube (bound-constrained optimization) to facilitate solving the subproblem.

To obtain the model points $\mathcal{X}^{model}_t$, we first search the history of function evaluations for points that lie within $\Delta_t^{search}=\gamma^{search}\Delta_t^{search}$ neighborhood of the candidate point $x_t^*$:
\begin{align}
    \mathcal{X}^{existing}_t\equiv\{x\in\mathcal{H}_t|\Hquad\lVert x^*_t-x\rVert\leq\Delta^{search}_t\}
    \label{eq:hist-search}
\end{align}
We filter the set of existing points \textcolor{red}{to improve the quality of the sample geometry}:
\begin{align}
    \mathcal{X}^{filtered}_t\equiv Filter (\mathcal{X}^{existing}_t) \equiv\{ Filter (x)|\Hquad x\in \mathcal{X}^{existing}_t\}
    \label{eq:filtering}
\end{align}
Where the filter function can be applied to, for example, to detect clusters and return the corresponding centers, discard points outside of the trust region, or do nothing by returning $\mathcal{X}_t^{existing}$.
\comment[id=MP]{TODO Mariam: add examples from /refer to wild paper}

If the size of the filtered sample is smaller than the target sample size $n^{target}$, we sample new points in the current trust region:

\begin{align}
    \mathcal{X}^{new}_{t}\equiv Sample(\mathcal{X}_t^{filtered},R_t,n^{target})
    \label{eq:sample-points}
\end{align}
where the sampling function nests several strategies for sampling either in the interior or on the hull of the trust region.

Having built the vector model $M_t^v$, we approximate the full criterion function $f$ by aggregating $M_t^v$ into a scalar model:
\begin{align}
    M_t^s = Aggregate(M_t^v)
    \label{eq:aggregate}
\end{align}
where the $Aggregate$ function allows for different aggregation strategies fit for different problems and polynomial degrees of the residual models.

To find a candidate step $s_t$, we approximately solve for the optimum of the aggregate model in the current trust region:
\begin{align}
    s_t\approx \underset{{\Hquad s\in B_t}}{arg\,\min}M_t^s(s)
    \label{eq:tr-subproblem}
\end{align}
Where $B$ is the scaled trust region, as discussed in the fitting step.

To avoid a fast collapse of the trust region, we impose a lower threshold on the step size $\lVert s_t\rVert$ to accept a candidate step. To this end, we drop points that we consider to be "bad" in the following sense: We first discard points that are outside of the trust region. If then we are left with only points that are inside the trust region, we discard points such that we are left with points that are most fanned out relative to the trust region center. This approach reflects on the fact that we want to obtain as uniform coverage of the trust region as possible. Formally, we have:
\begin{align}
    \mathcal{X}_t^{reduced} = Drop(\mathcal{X}_t^{model},\Delta_t^{region} n^{drop})
    \label{eq:improve-geo}
\end{align}
where $n^{drop}\geq1$.

We then fit a vector model and solve the trust region subproblem \ref{eq:tr-subproblem}. We repeat these steps until we obtain a satisfactory step. If $|\mathcal{X}_t^{reduced}|$ drops below the target sample size $n^{target}$ before we obtain a large candidate step, in addition to \ref{eq:improve-geo} we sample new points.


We evaluate the aggregate criterion $f$ at $x^{*}_t+s_t$, and compute the decrease in the objective produced by the candidate step:
\begin{align}
    \Delta f_t\equiv f(x_t^*) - f(x_t^*+s_t)
    \label{eq:actual-improvement}
\end{align}

Similarly, we compute the expected improvement predicted my the aggregate model:
\begin{align}
    \Delta M^{s}_t\equiv M_t^s(x_t^*) - M_t^s(x_t^*+s_t)
    \label{eq:expected-improvement}
\end{align}

In a comprehensive acceptance step, details of which we will discuss in section \ref{subsubsec:acceptance}, we take into account the actual and expected improvements $\Delta f_t$ and $\Delta M_t^s$, respectively, to obtain the candidate point for the next iteration $x_{t+1}^*$ and the relative improvement $\rho_t\equiv \Delta f_t/ \Delta M^s_t$:

\begin{align}
    Accept(s_t,x_t^{*},\Delta f_t,\Delta M_t^s;\Hquad\cdot\Hquad)=(Decision_t,x_{t+1}^{*},\rho_t;\Hquad\cdot\Hquad)
    \label{eq:acceptance-core}
\end{align}
The $Accept$ function nests the classical trust region acceptance step:
\begin{align}
    x_{t+1}^*=\begin{cases}
        x_t^*+s_t,\quad&\rho_t\geq\rho^{min}\\
        x_t^*,\quad&\rho_t<\rho^{min}
    \end{cases}
    \label{eq:accept-classic}
\end{align}
as a special case.

Having obtained the acceptance results, we expand the trust region radius for the next iteration to $\Delta_{t+1}^{region}=\gamma^{inc}\Delta_t^{region}$ if both the ratio $\rho_t$ and the step size $\lVert s_t\rVert$ are sufficiently large. For low values of $\rho_t$, we shrink the radius to $\Delta^{region}_{t+1} = \gamma^{dec}\Delta_t^{region}$
